var hz = 10;
console.log('Started ' + __filename);

// NOTE: The limitations of a free developer Firebase account: 5 GB Data Transfer, 50 Max Connections, 100 MB Data Storage
var Firebase = require('firebase');
// Open Firebase connection
var huboRef = new Firebase('https://hubo-firebase.firebaseIO.com');

// Communicate with ACH
var hubo_ach = require('hubo-ach-readonly');

// var path = require('path');

// var util = require('util');
//var coffeescript = require('connect-coffee-script');
// var fs = require('fs');
var state = {}
var updateID = null;
var main = function() {
    var r = hubo_ach.init();
    if (!r) {
        console.log("Error initializing hubo-ach-readonly module. Likely cause: hubo-daemon is not running.")
        return
    }
    updateID = setInterval(update,1000/hz);
}

var update = function() {
    state = hubo_ach.getState()
    console.log('RSP: ' + state.joint[11].ref);
    huboRef.child('state').set(state);
}

main();

// // This event is run when the Python bridge writes to its standard out, which 
// // we read in an interpret.
// jointControl.stdout.on('data', function(data) {
//     var lines = data.toString().split('\n');
//     for (i=0; i<lines.length; i++) {
//         var line = lines[i].trim();
//         // Skip empty lines.
//         if (line == "") {
//             continue;
//         }
//         // Parse line
//         line = line.split(':');
//         // console.log('Joint Control: ' + line);
//         var key = line[0].trim();
//         var value = line[1].trim();
//         // Update model
//         switch(key) {
//             case "status":
//                 console.log("status = " + value);
//                 ach_status = value;
//                 break;
//             case "pos":
//                 // if (ach_status == "ACH_OK") {
//                     console.log("\nPOSE = " + value);
//                     setPos(string_to_pose(value));
//                 // }
//                 break;
//             case "ref":
//                 // if (ach_status == "ACH_OK") {
//                     console.log("\nREF = " + value);
//                     setRef(string_to_pose(value));
//                 // }
//                 break;
//             case "HUBO_FT_R_HAND":
//                 setFT("HUBO_FT_R_HAND", value);
//                 break;
//             case "HUBO_FT_L_HAND":
//                 setFT("HUBO_FT_L_HAND", value);
//                 break;
//             case "HUBO_FT_R_FOOT":
//                 setFT("HUBO_FT_R_FOOT", value);
//                 break;
//             case "HUBO_FT_L_FOOT":
//                 setFT("HUBO_FT_L_FOOT", value);
//                 break;
//         }
//     }
//     jointControl.stdin.write('ok\n');
// });

// // This let's us know if the Python bridge crashes. :-(
// jointControl.on('exit', function(code) {
//     console.log('Joint Control exited with code ' + code);
// });

// function string_to_pose(pose_string) {
//     return pose_string.trim().split(/\s+/);
// }

// function setPos(pose) {
//     if (notZeros(pose)) {
//         for (var i = 0; i < joint_names.length; i++) {
//             jointRef.child(joint_names[i]).child("pos").set(parseFloat(pose[i]));
//         }
//     }
// }

// function setRef(pose) {
//     for (var i = 0; i < joint_names.length; i++) {
//         jointRef.child(joint_names[i]).child("ref").set(parseFloat(pose[i]));
//     }
// }

// function setFT(ft_name, ft_string) {
//     // TODO: Re-write this so if the string to parse is not valid, it will not crash whole server.
//     var tokens = ft_string.split(',');
//     ftRef.child(ft_name).child('m_x').set(parseFloat(tokens[0]));
//     ftRef.child(ft_name).child('m_y').set(parseFloat(tokens[1]));
//     ftRef.child(ft_name).child('f_z').set(parseFloat(tokens[2]));
// }

// // For some reason, ACH likes to return frames with ALL ZEROS, even when the status is ACH_OK sometimes.
// // Since this is highly undesireable behavior, I'm checking and discarding such frames.
// function notZeros(pose) {
//     for (var i = 0; i < pose.length; i++) {
//         if (pose[i] != 0) {
//             return true;
//         }
//     }
//     return false;
// }



// // Setup server
// var express = require('express'); // this is the webserver
// var app = express();
// app.use(express.bodyParser());
// app.use(express.methodOverride());
// app.use(app.router);
// // Serve static files out of the /out directory generated by Docpad. (Clever!)
// app.use(express.static(path.join(__dirname, '../out')));


// app.set('views', __dirname + '/views');
// app.set('view engine', 'jade');

// app.use(coffeescript({
//   src: "public",
//   bare: true
// }));



// app.get('/', function (req, res) {
//     res.render('index');
// });

// app.put('/joints/:id', function (req, res) {
//     var jointId = req.params.id.toUpperCase();
//     var jointValue = parseFloat(req.body['newValue']);
//     console.log('jointId: ' + jointId + ', jointValue: ' + jointValue);
//     jointControl.stdin.write(jointId + ' ' + jointValue + '\n'); 
//     res.send(200);
// });

// app.put('/pose', function (req, res) {
//     var pose = req.body['pose'];
//     console.log(pose);
//     var header = req.body['header'];
//     console.log(header);

//     var names = header.trim().split(/\s+/);
//     var values = pose.trim().split(/\s+/);
//     //console.log(values);
//     for (_i = 0, _len = names.length; _i < _len; _i++) {
//         name = names[_i];
//         console.log(name + ': ' + values[_i]);
//         jointControl.stdin.write(name + ' ' + values[_i] + '\n'); 
//     }
//     jointControl.stdin.write('updateRef' + '\n');
//     res.send(200);
// });

// app.put('/playTrajectory', function (req, res) {
//     var freq = req.body['frequency'];
//     var data = req.body['trajectory'];
//     var header = req.body['header']; // TODO: Include in traj file.
//     fs.writeFile("public/data/temp.traj", data, function(err) {
//         if(err) {
//             console.log(err);
//         } else {
//             console.log("The trajectory file was saved.");
//         }
//     }); 

//     // TODO: I'm getting a lot of "Set tty unbuffered error" when using the newer version
//     // of hubo-read-trajectory. I don't get this when using the Python subprocess module.
//     // So maybe it makes more sense to spawn it from python?

//     // var hubo_read_trajectory = spawn('/usr/bin/hubo-read-trajectory', 
//     //     ['-n', 'public/data/temp.traj', '-f', freq],
//     //     { stdio: 'pipe' } );

//     var hubo_read_trajectory = exec('/usr/bin/hubo-read-trajectory -n public/data/temp.traj -f ' + freq,
//         function (error, stdout, stderr) {
//             console.log('stdout: ' + stdout);
//             console.log('stderr: ' + stderr);
//             if (error !== null) {
//               console.log('exec error: ' + error);
//             }
//         });

//     // hubo_read_trajectory.on('close', function (code) {
//     //   if (code !== 0) {
//     //     console.log('hubo-read-trajectory exited with code ' + code);
//     //   }
//     // });
//     // hubo_read_trajectory.stderr.on('data', function (data) {
//     //   console.log('stderr: ' + data);
//     // });
//     // hubo_read_trajectory.stdout.on('data', function (data) {
//     //   console.log('stdout: ' + data);
//     // });
//     res.send(200);
// });

// app.get('/restartSim', function (req, res) {
//     var p1 = exec('sudo /usr/bin/hubo-ach killall > /dev/null 2>&1',
//         function (error, stdout, stderr) {
//             console.log('ran killall');
//             // console.log('stdout: ' + stdout);
//             // if (stderr !== null) {
//             //     console.log('stderr: ' + stderr);
//             // }
//             // if (error !== null) {
//             //   console.log('exec error: ' + error);
//             // }
//             // python /etc/hubo-ach/virtualHubo.py physics drc
//             var p2 = exec('sudo /usr/bin/hubo-ach sim && python /etc/hubo-ach/virtualHubo.py physics drc > /dev/null 2>&1 &', ///usr/bin/hubo-ach sim openhubo physics drc',
//                 function (error, stdout, stderr) {
//                     console.log('restarted openHubo');
//                     // console.log('stdout: ' + stdout);
//                     // if (stderr !== null) {
//                     //     console.log('stderr: ' + stderr);
//                     // }
//                     // if (error !== null) {
//                     //   console.log('exec error: ' + error);
//                     // }
//                     setTimeout(function () {
//                         // restart python script
//                         jointControl.stdin.write('\n');
//                         jointControl = spawn('python', ['joint_control.py']);
//                         console.log('Restarted joint_control.py');
//                     },7000);
//                 });
//         });

//     // hubo_read_trajectory.on('close', function (code) {
//     //   if (code !== 0) {
//     //     console.log('hubo-read-trajectory exited with code ' + code);
//     //   }
//     // });
//     // hubo_read_trajectory.stderr.on('data', function (data) {
//     //   console.log('stderr: ' + data);
//     // });
//     // hubo_read_trajectory.stdout.on('data', function (data) {
//     //   console.log('stdout: ' + data);
//     // });
//     res.send(200);
// });

// app.put('/updateRef', function (req, res) {
//     jointControl.stdin.write('updateRef' + '\n');
//     res.send(200);
// });

// app.put('/save', function (req, res) {
//     var data = req.body['data'];
//     fs.writeFile("public/data/test.traj", data, function(err) {
//         if(err) {
//             console.log(err);
//         } else {
//             console.log("The file was saved!");
//         }
//     }); 
//     res.send(200);
// });

// //jointRef.on('child_changed', function(snapshot) {
// //  var jointId = snapshot.name(),
// //      jointValue = snapshot.val();
// //  console.log('jointId: ' + jointId + ', jointValue: ' + jointValue);
// //  jointControl.stdin.write(jointId + ' ' + jointValue/100 + '\n'); 
// //});

// app.get('/exit', function(req, res) {
//     jointControl.stdin.write('\n');
// });





// app.listen(3000);
