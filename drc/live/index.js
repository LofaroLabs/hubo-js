// Generated by CoffeeScript 1.7.1
var FT_Sensor, adaptCanvasSize, computeColor, extractLimits, flashLED, lerp, socket, use_socket;

use_socket = true;

if (use_socket) {
  socket = io.connect(':6060');
} else {
  window.serial_stateRef = new Firebase('http://drc-hubo.firebaseIO.com/serial_state');
}

window.ledTimeoutId = null;

flashLED = function() {
  window.clearTimeout(window.ledTimeoutId);
  $('#led').show();
  return window.ledTimeoutId = setTimeout(function() {
    return $('#led').hide();
  }, 100);
};

FT_Sensor = (function() {
  function FT_Sensor(name) {
    this.name = name;
    this.m_x_obj = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 0.15, 0xFF0000);
    this.m_y_obj = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 0.15, 0x00FF00);
    this.f_z_obj = new THREE.ArrowHelper(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 0), 0.15, 0x0000FF);
    this.axis = new THREE.Object3D();
    this.axis.add(this.m_x_obj);
    this.axis.add(this.m_y_obj);
    this.axis.add(this.f_z_obj);
  }

  FT_Sensor.prototype.updateColor = function(o) {
    var fz_gradient, mx_gradient, my_gradient;
    mx_gradient = lerp(o.mx_min, o.mx_max, 0, this.m_x);
    my_gradient = lerp(o.my_min, o.my_max, 0, this.m_y);
    fz_gradient = lerp(o.fz_min, o.fz_max, 0, this.f_z);
    this.axis.children[0].setColor(computeColor(mx_gradient).getHex());
    this.axis.children[1].setColor(computeColor(my_gradient).getHex());
    return this.axis.children[2].setColor(computeColor(fz_gradient).getHex());
  };

  return FT_Sensor;

})();

computeColor = function(t) {
  var temp, y;
  temp = new THREE.Color();
  y = $('#color_limits .y_threshold').val();
  if (t > y) {
    console.log("t>y");
    temp.setRGB(1, 1 - lerp(y, 1, 0, t), 0);
    console.log(temp);
  } else {
    temp.setRGB(lerp(0, y, 0, t), 1, 0);
  }
  return temp;
};

lerp = function(min, max, zero, t) {
  if (t > max) {
    t = max;
  }
  if (t < min) {
    t = min;
  }
  if (t < zero) {
    return Math.min((zero - t) / (zero - min), 1);
  } else {
    return Math.min((t - zero) / (max - zero), 1);
  }
};

extractLimits = function(el) {
  var o;
  o = {};
  o.mx_min = $(el).find(".m_x_min").val();
  o.mx_max = $(el).find(".m_x_max").val();
  o.my_min = $(el).find(".m_y_min").val();
  o.my_max = $(el).find(".m_y_max").val();
  o.fz_min = $(el).find(".f_z_min").val();
  o.fz_max = $(el).find(".f_z_max").val();
  return o;
};

adaptCanvasSize = function() {
  var height, width;
  if (document.webkitIsFullScreen) {
    width = $(window).width();
    height = $(window).height();
  } else {
    width = Math.min($(window).width(), $(window).height());
    height = width;
  }
  $('#hubo_container').width(width);
  $('#hubo_container').height(height);
  return hubo.canvas.resize(width, height);
};

$(document).ready(function() {
  var c, callback, progress, size;
  window.stats = new Stats();
  stats.setMode(0);
  $('#hubo_container').append(stats.domElement);
  stats.domElement.style.position = 'relative';
  stats.domElement.style.float = 'right';
  $(window).on('orientationchange resize', function() {
    return setTimeout(adaptCanvasSize, 500);
  });
  size = Math.min($(window).width(), $(window).height());
  $('#hubo_container').width(size);
  $('#hubo_container').height(size);
  c = new Hubo.DefaultCanvas("#hubo_container");
  window.texture = THREE.ImageUtils.loadTexture('checkerboard.png', THREE.Linear);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.x = 20;
  texture.repeat.y = 20;
  return window.hubo = new Hubo("dirk", callback = function() {
    var floorG, floorM, updateModel;
    c.add(hubo);
    hubo.autorender = false;
    $("#load").hide();
    floorG = new THREE.PlaneGeometry(20, 20);
    floorM = new THREE.MeshBasicMaterial({
      map: texture
    });
    window.floor = new THREE.Mesh(floorG, floorM);
    floor.position.z = -1.17;
    floor.overdraw = true;
    c.scene.add(floor);
    if (hubo.ft == null) {
      hubo.ft = {};
    }
    hubo.ft.HUBO_FT_R_HAND = new FT_Sensor();
    hubo.ft.HUBO_FT_L_HAND = new FT_Sensor();
    hubo.ft.HUBO_FT_R_FOOT = new FT_Sensor();
    hubo.ft.HUBO_FT_L_FOOT = new FT_Sensor();
    hubo.links.Body_RWR.add(hubo.ft.HUBO_FT_R_HAND.axis);
    hubo.links.Body_LWR.add(hubo.ft.HUBO_FT_L_HAND.axis);
    hubo.links.Body_RAR.add(hubo.ft.HUBO_FT_R_FOOT.axis);
    hubo.links.Body_LAR.add(hubo.ft.HUBO_FT_L_FOOT.axis);
    hubo.ft.HUBO_FT_R_HAND.axis.position = new THREE.Vector3(0.1, 0, 0);
    hubo.ft.HUBO_FT_L_HAND.axis.position = new THREE.Vector3(0.1, 0, 0);
    hubo.ft.HUBO_FT_R_FOOT.axis.position = new THREE.Vector3(-0.05, 0, -0.15);
    hubo.ft.HUBO_FT_L_FOOT.axis.position = new THREE.Vector3(-0.05, 0, -0.15);
    hubo.ft.HUBO_FT_R_HAND.axis.rotation.y = -Math.PI / 2;
    hubo.ft.HUBO_FT_L_HAND.axis.rotation.y = -Math.PI / 2;
    updateModel = function(serial_state) {
      var foot_limits, hand_limits, jointType, state;
      state = JSON.parse(serial_state);
      jointType = $('#joint-toggle').val();
      hand_limits = extractLimits($('#ft_hand_limits'));
      foot_limits = extractLimits($('#ft_foot_limits'));
      hubo.ft["HUBO_FT_R_HAND"].m_x = state.ft[0];
      hubo.ft["HUBO_FT_R_HAND"].m_y = state.ft[1];
      hubo.ft["HUBO_FT_R_HAND"].f_z = state.ft[2];
      hubo.ft["HUBO_FT_R_HAND"].updateColor(hand_limits);
      hubo.ft["HUBO_FT_L_HAND"].m_x = state.ft[3];
      hubo.ft["HUBO_FT_L_HAND"].m_y = state.ft[4];
      hubo.ft["HUBO_FT_L_HAND"].f_z = state.ft[5];
      hubo.ft["HUBO_FT_L_HAND"].updateColor(hand_limits);
      hubo.ft["HUBO_FT_R_FOOT"].m_x = state.ft[6];
      hubo.ft["HUBO_FT_R_FOOT"].m_y = state.ft[7];
      hubo.ft["HUBO_FT_R_FOOT"].f_z = state.ft[8];
      hubo.ft["HUBO_FT_R_FOOT"].updateColor(foot_limits);
      hubo.ft["HUBO_FT_L_FOOT"].m_x = state.ft[9];
      hubo.ft["HUBO_FT_L_FOOT"].m_y = state.ft[10];
      hubo.ft["HUBO_FT_L_FOOT"].f_z = state.ft[11];
      hubo.ft["HUBO_FT_L_FOOT"].updateColor(foot_limits);
      hubo.links.Body_Torso.rotation.x = state.imu[2].a_x;
      hubo.links.Body_Torso.rotation.y = state.imu[2].a_y;
      hubo.motors["WST"].value = state[jointType][0];
      hubo.motors["NKY"].value = state[jointType][1];
      hubo.motors["NK1"].value = state[jointType][2];
      hubo.motors["NK2"].value = state[jointType][3];
      hubo.motors["LSP"].value = state[jointType][4];
      hubo.motors["LSR"].value = state[jointType][5];
      hubo.motors["LSY"].value = state[jointType][6];
      hubo.motors["LEB"].value = state[jointType][7];
      hubo.motors["LWY"].value = state[jointType][8];
      hubo.motors["LWR"].value = state[jointType][9];
      hubo.motors["LWP"].value = state[jointType][10];
      hubo.motors["RSP"].value = state[jointType][11];
      hubo.motors["RSR"].value = state[jointType][12];
      hubo.motors["RSY"].value = state[jointType][13];
      hubo.motors["REB"].value = state[jointType][14];
      hubo.motors["RWY"].value = state[jointType][15];
      hubo.motors["RWR"].value = state[jointType][16];
      hubo.motors["RWP"].value = state[jointType][17];
      hubo.motors["LHY"].value = state[jointType][19];
      hubo.motors["LHR"].value = state[jointType][20];
      hubo.motors["LHP"].value = state[jointType][21];
      hubo.motors["LKN"].value = state[jointType][22];
      hubo.motors["LAP"].value = state[jointType][23];
      hubo.motors["LAR"].value = state[jointType][24];
      hubo.motors["RHY"].value = state[jointType][26];
      hubo.motors["RHR"].value = state[jointType][27];
      hubo.motors["RHP"].value = state[jointType][28];
      hubo.motors["RKN"].value = state[jointType][29];
      hubo.motors["RAP"].value = state[jointType][30];
      hubo.motors["RAR"].value = state[jointType][31];
      hubo.motors["RF1"].value = state[jointType][32];
      hubo.motors["LF1"].value = state[jointType][37];
      hubo.canvas.render();
      stats.end();
      return stats.begin();
    };
    if (use_socket) {
      socket.on('serial_state', function(serial_state) {
        window.serial_state = serial_state;
        flashLED();
        return updateModel(serial_state);
      });
    } else {
      serial_stateRef.on('value', function(snapshot) {
        var serial_state;
        serial_state = snapshot.val();
        window.serial_state = serial_state;
        flashLED();
        return updateModel(serial_state);
      });
    }
    $('#joint-toggle').on('slidestop', function() {
      return updateModel(window.serial_state);
    });
    $('#fullscreen-toggle').on('slidestop', function() {
      if ($('#fullscreen-toggle').val() === "on") {
        if (document.webkitFullscreenEnabled) {
          return document.getElementById('hubo_container').webkitRequestFullscreen();
        }
      } else {
        if (document.webkitFullscreenEnabled) {
          return document.webkitExitFullscreen();
        }
      }
    });
    $(document).on('webkitfullscreenchange', function() {
      if (document.webkitIsFullScreen) {
        setTimeout(adaptCanvasSize, 500);
        return $('#fullscreen-toggle').val("on").slider("refresh");
      } else {
        setTimeout(adaptCanvasSize, 500);
        return $('#fullscreen-toggle').val("off").slider("refresh");
      }
    });
    return c.render();
  }, progress = function(step, total, node) {
    return $("#load").html("Loading " + step + "/" + total);
  });
});
